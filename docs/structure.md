# 系统架构

## 模块化

虽然在之前的系统设计上，我们称系统中的每一个功能组件都是一个模块，
但实际上在具体的代码实现，每个模块的内部实现不同，导致其具体实现上有一定的差异，
使得我们需要为每个类都涉及一套代码实现，并且还需要手动地加载和连接各个模块。

因此，为了简化这部分的代码开发工作量，让系统本身自动化地完成模块加载和连接，
我们提出了模块化的思想。

### 1. 概念

这里模块化思想其实与 Linux 系统中的文件系统如出一辙，
在 Linux 系统中，所有的硬件设备、文件内容和文件夹都属于文件，
共用一套统一的 IO 控制接口。

在我们这套系统中也是如此，任何一个具体模块都继承与一个统一的模块接口，
它们共用一套统一的启动、运行和管理接口。
此外，模块之间也能互相嵌套（不允许发生循环依赖），父模块会自动加载子模块。

### 2. 属性

其中 `name` 表示模块的名称，而 `kind` 表示模块的具体实现类型。

```python
class ModuleInterface(metaclass=ABCMeta):
    def __init__(self, name: str, kind: str=BASIC):
        # 模块的基本信息
        self.__is_running = False
        self.__name = name
        self.__kind = kind

        # 线程相关
        self.__threads: List[Thread] = []

        # 子模块相关的属性
        self.__sub_modules_list: List[str|Dict[str, str]] = []
        self._sub_modules: Dict[str, Self] = {}
        self.__height = 0
```

### 3. 启动

#### a. 生命周期

启动逻辑较为复杂，他具体包括如下几个步骤。

1. **加载配置文件**：每次启动模块时都会重新加载配置文件，
   以保证可以在关闭本程序的前提，热更新配置文件。
2. **加载子模块**：由于存在模块嵌套，因此父模块启动时，需要先启动子模块
3. **启动子模块**：逐一启动运行加载好的模块
4. **模块自检**：通过调用自定义的检测逻辑，保证模块时可运行的

#### b. 钩子函数

每个模块而言可能存在一些自定义的加载逻辑，
在本系统中我们通过钩子函数进行实现。
通过重写钩子函数，自定义的加载逻辑就可以在对应的启动的生命周期中运行。
目前提供的钩子函数如下。

-   加载子模块前
-   加载子模块后
-   运行成功前
-   运行成功后

> 注意：运行成功前后这两个钩子函数，主要针对 `is_running` 这个状态变量改变前后。
> 因为 `is_running` 可能会影响一些持久运行的线程，这个在后面的内容会介绍。

#### c. 多线程

某些模块在启动之后，需要持续的运行处理，
因此需要使用多线程的技术。
本系统为了对多线程的创建和回收进行统一的管理，
因此封装了 `make_thread` 用于创建和运行线程。
该函数创建的线程对象会存储在模块内部，
开发者需要自行选择合适的钩子函数作为时机，创建和运行线程。

在线程内部，通常使用死循环的方式进行循环操作，以保证可持续运行。
但是在实际实现上，最好通过一些标志位来停止这个死循环操作，
以进行优化的停止。目前是推荐 `is_running` 状态类控制。

> 注意：未来可能会通过其他的标志状态来控制这个线程的运行情况。

### 4. 停止

模块的停止操作相比启动来说简单许多，其停止逻辑如下。
为了进行优雅的停机，模块会等待处理线程运行完毕之后，才正式停机。

1. 停止模块中的线程
2. 停止所有子模块

当模块运行失败时，需要通过停止操作将所有子模块关闭停止。

### 5. 加载子模块

自动加载子模块是模块化系统中最重要的功能之一，
它省去大部分导入模块，设置配置信息和管理子模块的工作，
只需要通过配置文件和少量的代码就可以拉起整个庞大系统。

#### a. 设置模块

每个模块都提供 `_set_sub_modules` 函数对子模块进行设置，
输入的参数类型如下。
一个模块可以设置多个模块，其中 name 指定的模块的名称，
其默认会从`module.*`路径下寻找模块。
如果模块并不存在于默认路径中，则可以手动设置加载路径，
但请注意一定需要按照`a.b.c`个格式，进行导入。

```python
 ({ name: str, path: str } | str)[]
```

#### b. 动态导入

设置模块是解决模块中包含什么子模块的问题，
而动态导入则是解决导入何种模块的具体实现，以及怎么导入的问题。
主要分成 2 种情况。

如果该模块只有一种具体实现，例如 `booter` 和 `core`，
这类模块主要是用于阻止子模块之间的联系。
那么配置文件中就不需要指定具体的具体的实现类型，
动态导入程序就会直接从 `path.name` 模块。

如果该模块中存在多种具体类型，例如 `crawler` 和 `bot` 等，
那么动态导入程序则会从配置文件中的 `use.module.name` 中读取实现类型，
从而从`path.module.name.kind`中导入模块。

值得注意的是，本系统存在两个特殊的类型。

-   `basic`: 针对只有一种具体实现的模块
-   `null`: 空模块，只用于占位，实际上加载时返回 None
