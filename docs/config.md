# 配置文件

由于本系统会调用很多外部的 API 或服务，
同时又不能将配置信息硬编码进代码中，
因此需要使用代码统一管理。

在配置文件中，我们在调用的时候需要使用动态链接，
比如对于 API Key 字符串信息时，如果使用静态链接，
那么这些配置信息只有在对象初始化时会被加载，
此后就不会再改变。
但如果使用动态链接，每次需要使用该信息时，
都会访问单例模式中读取对应信息，进行动态加载。
通过动态链接的方式，就可以保证每次都能使用到最新的配置信息。

> 配置信息主要使用 字典 存储，
> 当读取字典时，由于其存放在堆内，
> 如果通过赋值的方式使用，仍然可以指向同一块内存地址中，
> 再修改其中值的时候，也能保证数据一致性,
> 但如果使用的基本数据类型，这样数据被修改时，则不会进行同步。
>
> 所以无论如何，还是动态链接的方式，保证配置信息呗修改时，
> 其他模块再使用能够访问到

```python
# 静态链接
api_key = config['apiKey']

# 动态链接
@property
def api_key(self) -> str:
    return config['apiKey']
```

## 配置信息重加载

配置信息存在在硬盘中，当程序第一次运行时，
会被加载到内存中。
此时，如果文件系统的配置文件被修改，则不会影响内存中的副本。

我们程序分为两个情况，运行状态和非运行状态。
在运行时，我们不允许用户修改配置文件，
只有当用户停止运行时，才能修改配置文件，
而每次开始运行时，都会进行一次**配置信息重加载**。

注意，这里的每次开始运行和程序第一次运行时不同，
后者时通过`app.py` 或 `cli.py`运行程序，
而前者是用户调用`Booter.start()`。
这样设计是允许再程序运行时也能动态控制配置文件，
避免用户为了修改配置文件，频繁开启和退出主程序。
